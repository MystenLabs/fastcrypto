// Copyright (c) 2022, Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

use crate::math::parameterized_group::ParameterizedGroupElement;
use fastcrypto::groups::Doubling;
use fastcrypto::hash::{HashFunction, Keccak256};
use modulus::RSAModulus;
use num_bigint::BigUint;
use num_traits::One;
use serde::Serialize;
use std::ops::{Add, Mul};

/// When generating a random element, we sample uniformly 8 bytes larger than the modulus to limit the bias by 2^{-64}.
const BIAS_BYTES: usize = 16;

pub mod modulus;

/// This represents an element of the subgroup of an RSA group <i>Z<sub>N</sub><sup>*</sup> / <±1></i>
/// where <i>N</i> is the product of two large primes. See also [RSAModulus].
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RSAGroupElement<'a> {
    value: BigUint,

    // We assume that the modulus is known from the context, so it is not serialized.
    #[serde(skip)]
    modulus: &'a RSAModulus,
}

impl<'a> RSAGroupElement<'a> {
    /// Create a new RSA group element with the given value and modulus. The value will be reduced to
    /// the subgroup <i>Z<sub>N</sub><sup>*</sup> / <±1></i>, so it does not need to be in canonical
    /// representation.
    pub fn new(value: BigUint, modulus: &'a RSAModulus) -> Self {
        Self {
            value: modulus.reduce(value),
            modulus,
        }
    }

    /// Return the canonical representation of this group element.
    pub fn value(&self) -> &BigUint {
        &self.value
    }

    /// Generate a uniformly random element of the subgroup <i>Z<sub>N</sub><sup>*</sup> / <±1></i>
    /// using the given seed.
    pub fn from_seed(seed: &[u8], modulus: &'a RSAModulus) -> Self {
        // The number of 32-byte chunks needed to sample enough bytes.
        let k = (modulus.value.bits().div_ceil(8) as usize + BIAS_BYTES).div_ceil(32);

        let bytes: Vec<u8> = (0..k)
            .flat_map(|i| {
                let mut hash = Keccak256::new();
                hash.update(i.to_be_bytes());
                hash.update(seed);
                hash.finalize().digest
            })
            .collect();

        Self::new(BigUint::from_bytes_be(&bytes), modulus)
    }
}

impl Add<&Self> for RSAGroupElement<'_> {
    type Output = Self;

    fn add(self, rhs: &Self) -> Self::Output {
        assert_eq!(self.modulus, rhs.modulus);
        Self::new(self.value.mul(&rhs.value), self.modulus)
    }
}

impl Doubling for RSAGroupElement<'_> {
    fn double(self) -> Self {
        Self::new(self.value.pow(2), self.modulus)
    }
}

impl<'a> ParameterizedGroupElement for RSAGroupElement<'a> {
    type ParameterType = &'a RSAModulus;

    fn zero(parameter: &Self::ParameterType) -> Self {
        Self::new(BigUint::one(), parameter)
    }

    fn is_in_group(&self, parameter: &Self::ParameterType) -> bool {
        self.modulus == *parameter
    }
}

#[cfg(test)]
mod tests {
    use crate::math::parameterized_group::ParameterizedGroupElement;
    use crate::rsa_group::modulus::test::{AMAZON_2048, GOOGLE_4096};
    use crate::rsa_group::RSAGroupElement;
    use fastcrypto::groups::Doubling;
    use num_bigint::BigUint;
    use num_integer::Integer;
    use num_traits::One;
    use std::ops::{Add, Shr};
    use std::str::FromStr;

    #[test]
    fn test_group_ops() {
        // Add
        let zero = RSAGroupElement::zero(&GOOGLE_4096);
        let element = RSAGroupElement::new(BigUint::from(7u32), &GOOGLE_4096);
        let sum = element.clone().add(&zero);
        assert_eq!(&sum, &element);
        assert_eq!(sum, RSAGroupElement::new(BigUint::from(7u32), &GOOGLE_4096));

        // Double
        let expected_double = element.clone().add(&element);
        let double = element.double();
        assert_eq!(&double, &expected_double);
        assert_eq!(
            double,
            RSAGroupElement::new(BigUint::from(49u32), &GOOGLE_4096)
        );

        // Double zero
        assert_eq!(
            RSAGroupElement::zero(&GOOGLE_4096),
            RSAGroupElement::zero(&GOOGLE_4096)
        );

        // +1 = -1 in this group
        let minus_one = RSAGroupElement::new(&GOOGLE_4096.value - BigUint::one(), &GOOGLE_4096);
        let one = RSAGroupElement::new(BigUint::one(), &GOOGLE_4096);
        assert_eq!(minus_one, one);

        // Regression tests
        let random_element = RSAGroupElement::from_seed(b"seed", &GOOGLE_4096);
        assert_eq!(random_element.value, BigUint::from_str("360866889834943725985107352676415836472127174773483988153951732855604582863519168015673189156649576903715943633777393256959190704128634006514511295435504397849512907439186219981292340075168601932235129101791451211256417111091844883332684505551536232236284985649004445494090907450738750507798741684275499055707102993109563634927315549981273641432484681431180866489905127587747737808266622991393517789463590264756965519172413028702934334822725825745812586144189942569287070929695556373307226646342449259314193098952748850018528926350749993186936903187363955554071530779664392233183987927595691205699397451727133308519431568169899709687558543842224859459706849335942703041674574424193972043681268028113586057365386353805937463710963374088019872267322373404332176981293527909358739384729811113281333234246006178188184718798855397541456442608660850291478087542690663850305214982021063182643947296920050345913038748144694336470785308529002859157527887809719773040369676913472882300911371208096933613458263511767056834293010270500511774440023386075033185580705661664173540183153834202265741344614982824770212038697149662857153770575848074102810677836709281858524221732592034231610277756682606617573110546664615704620039875673570392407549936").unwrap());
        let other_random_element = RSAGroupElement::from_seed(b"other seed", &GOOGLE_4096);
        assert_eq!(other_random_element.value, BigUint::from_str("198637284650437659073292797263334081961638625349067194134861485207914987234272613379880226352149746323011428429350525504454616153908495963513599065050518800323376157796008062869302341473710887739055603560902952190980393502830521075861445330227164150028032835621274445814452985313400993406127401298299889837251265005092746868653764094805501781697109198650400112192485673795873801733433024550666348062968042299995493246132476876766748157593666430572105745632699050739926906876073040161149478650264974782317141979904497226143185401657386408595927329538652151986803260839158639923929406461638707769226197376751636660071335890837877984061236833068748846390169678882076550155660794536836319578400439110162450057271194514780109422843637871767585012515369907726645388072100796427682529038231120631794918527026750853365393055857163607634256148953791180508607752348513227876811227855573092039283152374646190782348670786208569802754454633573876596462611811872930861199569756148061424295228736705229600488897140361584506528657430231189673631986643014484184987298016378223010037333393649499252386408443484858538891560612707603436856491241669484292512880420137343253368887872702521462258708766962190525319906460370167774833569141862883584302362382").unwrap());
        let product = random_element + &other_random_element;
        assert_eq!(product.value, BigUint::from_str("303657472677467685407401420703334343061226608150723928428279878231757104222796503727895093415669473561121069548431036126855840460826719359221412717235404706573540326897911170039203304701080412683208639196643907643133035037424741991761829700626285669615522662861829303475724235602068923789233223344087147550928060991256992316140628204870018597697813439252100136142588759794502050385082118499062650548630660346187398670386903651163486670236952625039914802483406798283104733704215380360786876337195621742897352666946597751679090850522594357033417105795493206102340078121476304880771136023397169763704084354005116481007340839012952737742644343365159047238926713346604214895924265313952608641294607078672014065763583587571332369990826565387957490696734977929484258088709268191479792176300556227935170968333690119152316182348778085791685079167241625252686534182668466194240674937185848236903212770869089672780376706939009328858403237868419412241065131603502018576205618347695840091961094104102318494763582064450873641562290564138592166030120172620778086569493602507256405900089138897016424730047872185838238800919509940895889219219489601503124302347752873986747230420023433120131840337747837534212326477799327835152320595874737961047419681").unwrap());

        // Modular reduction of new elements
        let large_number = BigUint::from_str("3036574726774676854074014207033343430612266081507239284282798782317571042227965037278950934156694735611210695484310361268558404608267193592214127172354047065735403268979111700392033047010804126832086391966439076431330350374247419917618297006262856696155226628618293034757242356020689237892332233440871475509280609912569923161406282048700185976978134392521001361425887597945020503850821184990626505486306603461873986703869036511634866702369526250399148024834067982831047337042153803607868763371956217428973526669465977516790908505225943570334171057954932061023400781214763048807711360233971697637040843540051164810073408390129527377426443433651590472389267133466042148959242653139526086412946070786720140657635835875713323699908265653879574906967349779294842580887092681914797921763005562279351709683336901191523161823487780857916850791672416252526865341826684661942406749371858482369032127708690896727803767069390093288584032378684194122410651316035020185762056183476958400919610941041023184947635820644508736415622905641385921660301201726207780865694936025072564059000891388970164247300478721858382388009195099408958892192194896015031243023477528739867472304200234331201318403377478375342123264777993278351523205958747379610474196811231241234").unwrap();
        let large_number_reduced = large_number.mod_floor(&GOOGLE_4096.value);
        let large_number_as_group_element =
            RSAGroupElement::new(large_number.clone(), &GOOGLE_4096);
        assert!(&large_number_reduced >= &(&GOOGLE_4096.value).shr(1));
        assert_eq!(
            large_number_as_group_element.value,
            &GOOGLE_4096.value - &large_number_reduced
        );
        assert_eq!(
            large_number_as_group_element,
            RSAGroupElement::new(large_number_reduced.clone(), &GOOGLE_4096)
        );
    }

    #[test]
    fn test_is_in_group() {
        let element = RSAGroupElement::new(BigUint::from(7u32), &GOOGLE_4096);
        assert!(element.is_in_group(&GOOGLE_4096));
        assert!(!element.is_in_group(&AMAZON_2048));
    }
}
