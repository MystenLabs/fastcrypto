searchState.loadedDescShard("fastcrypto_tbls", 0, "A crate that implements threshold BLS (tBLS) and …\nThis module implements threshold Schnorr signatures. The …\nAssumptions:\nA Confirmation is sent during the second phase of the …\nMessage holds all encrypted shares a dealer sends during …\nOutput is the final output of the DKG protocol in case it …\nGenerics below use …\nWrapper for collecting everything related to a processed …\nUnique processed messages that are being used in the …\nProcessed messages that were not excluded after the third …\nList of complaints against other parties. Empty if there …\nExecute the previous two steps together.\nAlternative to complete() - Optimistic version that …\nAlternative to complete() - Optimistic variant that …\nCreate the first message to be broadcasted.\nThe encrypted shares created by the sender. Sorted …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMerge results from multiple ProcessedMessages so only one …\nCreate a new ECIES private key and send the public key to …\nAlternative to new(), to be used for:\nProcess a message and create the second message to be …\nAlternative to process_message for a known vss.c0 public …\nPossibly empty\nThe threshold needed to reconstruct the full key/signature.\nThe commitment of the secret polynomial created by the …\nCheck that partial public keys form a polynomial of the …\nChecks if vectors v1=(a1<em>G1, …, an</em>G1) and v2=(a1’*G2, …\nCheck that a pair (k, H) satisfies H = k*G using a random …\nChecks that a given set of evaluations is consistent with …\nCheck that a triplet (k, G, H) satisfies H = k*G using a …\nMulti-recipient encryption with a proof-of-possession of …\nSimple ECIES encryption using a generic group and …\nA recovery package that allows decrypting a <em>specific</em> ECIES …\nAssumption: Verify is called before …\nAssumption: Verify is called before decrypt and do not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmulates the output of an insecure DKG protocol (to be …\nNIZKPoK for the DL [G, xG].\nNIZKPoK for the DDH tuple [G, H=eG, xG, xH].\nCreate a new NIZKPoK for the DDH tuple [G, H=eG, xG, xH] …\nCreate a new NIZKPoK for the DL [G, xG] using the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify this NIZKPoK.\nPublic parameters of a party.\nWrapper for a set of nodes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet an iterator on the nodes.\nCreate a new set of nodes. Nodes must have consecutive ids …\nCreate a new set of nodes. Nodes must have consecutive ids …\nGet an iterator on the node ids.\nNumber of nodes.\nGet the node corresponding to a share id.\nGet an iterator on the share ids.\nGet the share ids of a node (ordered). Returns error if …\nTotal weight of the nodes.\nTotal weight of a subset of the parties. Returns error if …\nTypes\nA polynomial that is using a scalar for the variable x and …\nReturns the coefficients of the polynomial.\nReturn the constant term of the polynomial.\nCommits the scalar polynomial to the group and returns a …\nReturns the degree of the polynomial.\nReturns an upper bound for the degree of the polynomial. …\nDivide self by divisor, returning the quotient and …\nEvaluates the polynomial at the specified value.\nReturns the argument unchanged.\nGiven a set of shares with unique indices, compute the …\nGiven a set of shares with unique indices, compute what …\nCalls <code>U::from(self)</code>.\nCompute the extended GCD of two polynomials. Returns (g, …\nReturns a new polynomial of the given degree where each …\nReturns a new polynomial of the given degree where the …\nGiven exactly <code>t</code> polynomial evaluations, it will recover …\nChecks if a given share is valid.\nReturns a polynomial with the zero element.\nRandom Oracle from SHA3-512.\nEvaluate the random oracle on a given input.\nDerive a new random oracle from the current one and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a fresh random oracle with a given “session id”…\n<code>Public</code> represents the group over which the public keys are …\n<code>Signature</code> represents the group over which the signatures …\nTrait ThresholdBls provides sign &amp; verify functions for …\nInterpolate partial signatures to recover the full …\nSign a message using the private share/partial key.\nSign a message using one of more private share/partial …\nVerify a signature done by a partial key holder.\nVerify a set of signatures done by a partial key holder. …\nVerify a signature on a given message. This is standard …\nThe group to use for the signing\nDefault scalar\nImplementation of an asynchronous verifiable secret …\nImplementation of an asynchronous verifiable secret …\nThis represents a Dealer in the AVSS. There is exactly one …\nThe message broadcast by the dealer, containing the …\nThe result of a Receiver processing a Message: Either …\nThe output of a receiver: The shares for each nonce + …\nAll the shares given to a node. One share per the node’s …\nThe commitments to the polynomials will be used for key …\nCombine multiple outputs from different dealers into a …\nInterpolate shares from multiple outputs to create new …\nThe Dealer samples nonces, generates shares and broadcasts …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUpon receiving a complaint, a receiver verifies it and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new dealer.\nCreate a new receiver.\nEach receiver processes the message, verifies and decrypts …\nUpon receiving t valid responses to a complaint, the …\nThe public key corresponding to the secret the dealer is …\nGet the weight of this node (number of shares it has).\nThis represents a Dealer in the AVSS. There is exactly one …\nThe message broadcast by the dealer.\nThe result of processing a message by a receiver: either …\nThis represents a Receiver in the AVSS who receives shares …\nThe output of a receiver which is a batch of shares and …\nA batch of shares for a single share index, containing …\nThis represents a set of shares for a node. A total of L …\nThe share for the blinding polynomial.\nThe Dealer generates shares for the secrets and broadcasts …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUpon receiving a complaint, a receiver verifies it and …\nThe index of the share (i.e., the share id).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new dealer.\nCreate a new receiver.\nEach receiver processes the message, verifies and decrypts …\nUpon receiving t valid responses to a complaint, the …\nThe shares for each secret.\nGet all shares this node has for the i-th secret/nonce in …\nGet the weight of this node (number of shares it has).\nA complaint by an accuser that it could not decrypt or …\nA response to a complaint, containing a recovery package …\nTry to decrypt the shares for the accuser.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecoder for Reed-Solomon codes. This can correct up to …\nCompute the message polynomial. Returns an error if the …\nTry to correct the input and return the decoded message. …\nEncode the message using the Reed-Solomon code defined by …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new Gao decoder with the given evaluation points <code>a</code>…\nDerive a new verifying key from an existing one and a …\nAn iterator that yields presigning tuples (i, t_i, p_i).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBased on the output of a batched AVSS from multiple …\nGiven enough partial signatures, aggregate them into a …\nGenerate partial threshold Schnorr signatures for a given …\nWrapper of a value that is associated with a specific …\ntBLS with ThresholdBls12381MinSig types.\nIndexes of shares/private keys (0 is reserved for the …\nImplementation of [ThresholdBls] for BLS12-381-min-sig. A …\nBasic wrapper of a set of values that are not associated …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper function to add two evaluations. Panics if the …")