searchState.loadedDescShard("fastcrypto_zkp", 0, "Fastcrypto-zkp is an experimental crate that offers a …\nDefinition of the BN254 prime field.\nGroth16 verifier over the BLS12-381 elliptic curve …\nGroth16 verifier over the BN254 elliptic curve …\nSimple circuits used in benchmarks and demos\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes a uniformly random element using rejection …\nCircom-compatible deserialization of points\nA prepared Groth16 verifying key in the BLS12-381 …\nA Groth16 proof in the BLS12-381 construction.\nA Groth16 verifying key in the BLS12-381 construction.\nAPI that takes in serialized inputs\nCreate a prepared verifying key for Groth16 over the …\nVerify Groth16 proof over the BLS12-381 curve …\nA field element in the BN254 construction. Thin wrapper …\nA Groth16 proof in the BN254 construction. Thin wrapper …\nA Groth16 verifying key in the BN254 construction. Thin …\nAPI that takes in serialized inputs\nDeserialize a serialized Groth16 proof using arkworks’ …\nDeserialize a serialized Groth16 verifying key in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPoseidon hash function over BN254\nZk login utils\nGroth16 SNARK verifier\nZk login structs and utilities\nZk login entrypoints\nSize of scalars in the BN254 construction.\nDeserialize bytes as an Arkwork representation of a …\nVerify proof with a given verifying key in [struct …\nVerify Groth16 proof using the serialized form of the …\nThe output of the Poseidon hash function is a field …\nThe degree of the Merkle tree used to hash multiple …\nPoseidon hash function over BN254. The input vector cannot …\nCalculate the poseidon hash of an array of inputs. Each …\nCalculate the poseidon hash of the field element inputs. …\nA response struct for the salt server.\nThe response struct for the test issuer JWT token.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculate the Sui address based on address seed and …\nCalculate the nonce for the given parameters. Nonce is …\nReturn the OIDC URL for the given parameters. Crucially …\nCall the prover backend to get the zkLogin inputs based on …\nCall the salt server for the given jwt_token and return …\nCall test issuer for a JWT token based on the request …\nReturn the token exchange URL for the given auth code.\nCalculate the Sui address based on address seed and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJWT token string.\nGiven a 33-byte public key bytes (flag || pk_bytes), …\nThis is a helper function to store a pre-processed version …\nThe element <code>e(alpha * G, beta * H)</code> in <code>E::GT</code>.\nThe element <code>- delta * H</code> in <code>E::G2</code>, for use in pairings.\nDeserialize the prepared verifying key from the serialized …\nReturns the argument unchanged.\nTakes an input <code>ark_groth16::VerifyingKey</code> <code>vk</code> and returns a …\nThe element <code>- gamma * H</code> in <code>E::G2</code>, for use in pairings.\nCalls <code>U::from(self)</code>.\nSerialize the prepared verifying key to its vectors form.\nVerify Groth16 proof using the prepared verifying key (see …\nThe element vk.gamma_abc_g1, aka the …\nSee …\nhttps://api.arden.cc/auth/jwks\nExample: …\nDeserializer in little endian format. This trait can be …\nSerializer in little endian format. This trait can be …\nA claim consists of value and index_mod_4.\nhttps://accounts.credenza3.com/openid-configuration\nSee …\n…\nSee …\nStruct that contains info for a JWK. A list of them for …\nReader struct to parse all fields in a JWK from JSON.\nA struct of parsed JWT details, consists of kid, header, …\nKey to identify a JWK, consists of iss and kid.\nSee …\n…\nThis is a test issuer maintained by Mysten that will …\nSupported OIDC providers.\n…\nhttps://oauth2.playtron.one/.well-known/jwks.json\nThe provider config consists of iss string and jwk …\nSee https://slack.com/.well-known/openid-configuration\nThis is a test issuer that will return a JWT …\nhttps://auth.3dos.io/.well-known/openid-configuration\nTypes that can be converted to a vector of <code>F</code> elements. …\nSee …\nAll inputs required for the zk login proof verification …\nThe reader struct for the proving service response.\nThe struct for zk login proof.\nAlgorithm parameter, …\nConvert the Circom G1/G2/GT to arkworks G1/G2/GT\nCalculate the poseidon hash from selected fields from …\nThe general deserialize method that takes in customization …\nRSA public exponent, …\nFetch JWKs from the given provider and return a list of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the OIDCProvider for the given iss string.\nParse the proving service response and pass in the address …\nParse the proof from a json string.\nParse JWK from the reader struct.\nInitialize ZkLoginInputs from the\nGet the address seed string.\nReturns the provider config consisting of iss and jwk …\nGet the parsed iss string.\nGet the parsed kid string.\nGet the zk login proof.\nPads a stream of bytes and maps it to a field element\nInitialize JWTDetails by parsing header_base64 and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\niss string that identifies the OIDC provider.\niss string that identifies the OIDC provider.\nThe JWK url string for the given provider.\nkid string that identifies the JWK.\nKey type parameter, …\nRSA modulus, …\nCreate a new JwkId.\nCreate a new provider config.\nRead in the Claim and header string. Parse and validate …\nParse the JWK bytes received from the given provider and …\nThe general serialize method that takes in customization …\nDeserializer in little endian format. This trait can be …\nSerializer in little endian format. This trait can be …\nUse the secure global verifying key derived from ceremony.\nUse the insecure global verifying key.\nTypes that can be converted to a vector of <code>F</code> elements. …\nEnum to specify the environment to use for verifying keys.\nThe general deserialize method that takes in customization …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe general serialize method that takes in customization …\nEntry point for the ZkLogin API.\nVerify that the given parameters (name, value, aud, iss …\nVerify that the given parameters (address_seed and iss) …\nVerify a proof against its public inputs using the fixed …\nA dummy circuit that checks an addition constraint between …\nA circuit that checks a parametrized number of R1CS …\nthe first input to the circuit\nthe second input to the circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new instance of the Fibonacci circuit. We have to …\nthe number of constraints to the circuit\nThe number of variables to the circuit\nThis is a helper function to store a pre-processed version …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrepare the public inputs for use in […\nVerify Groth16 proof using the prepared verifying key (see …\nVerify Groth16 proof using the prepared verifying key (see …\nScalars given to the API are expected to be in …\nSerialization of GT elements is typically not standardized …\nDeserialize the element from a byte array.\nDeserialize bytes as an Arkworks representation of a …\nSerialize the element into a byte array.\nVerify Groth16 proof using the serialized form of the four …\nA struct that stores a Bn254 Fq field element as 32 bytes.\nA struct that stores a Bn254 Fr field element as 32 bytes.\nA G1 point in BN254 serialized as a vector of three …\nA G2 point in BN254 serialized as a vector of three …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the padded version of the field element. This …\nReturns the unpadded version of the field element. This …")