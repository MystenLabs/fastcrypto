rd_("BbBase point for the blinding factorB`The group to use for the signingAhBase point for the valuenDefault scalarAnthe first input to the circuitAothe second input to the circuitAhRSA public exponent, \xe2\x80\xa6A`RSA modulus, \xe2\x80\xa6CkThe threshold needed to reconstruct the full key/signature.BdDefinition of the BN254 prime field.AjContains the success valueBkReturn the constant term of the polynomial.ClThe public key corresponding to the secret the dealer is \xe2\x80\xa6AhContains the error valueAdHex string encoding.CkStruct that contains info for a JWK. A list of them for \xe2\x80\xa6CeThis represents a Verifiable Delay Function (VDF) \xe2\x80\xa6CjThis module contains implementations of various AES modes.AhAlgorithm parameter, \xe2\x80\xa6BcAPI that takes in serialized inputs0Bmiss string that identifies the OIDC provider.0AaJWT token string.Bckid string that identifies the JWK.AgKey type parameter, \xe2\x80\xa6AmThe raw message to be signed.AgThe raw message signed.C`Compute <code>self.base_element * scalar</code>.BlCreate a new hash function of the given typeBnCreate a new digest containing the given bytesCkCreate a new scalar multiplier with the given base element.CiParse the header base64 string into a [struct JWTHeader].CjConstruct Merkle proof from list of hashes and leaf index.CmCreate a fresh random oracle with a given \xe2\x80\x9csession id\xe2\x80\x9d\xe2\x80\xa6CmCreate a new ECIES private key and send the public key to \xe2\x80\xa6CnCreate a new set of nodes. Nodes must have consecutive ids \xe2\x80\xa6AdCreate a new dealer.AfCreate a new receiver.10CgBased on the output of a batched AVSS from multiple \xe2\x80\xa6DkCreate a new Gao decoder with the given evaluation points <code>a</code>\xe2\x80\xa6CiCreate a new VDF using the group defined by the given \xe2\x80\xa60CkCreate a new RSA group element with the given value and \xe2\x80\xa6AcCreate a new JwkId.AmCreate a new provider config.CkRead in the Claim and header string. Parse and validate \xe2\x80\xa6CnCreate a new instance of the Fibonacci circuit. We have to \xe2\x80\xa6ClImplementation of a verifier following RSASSA-PKCS1-v1_5 \xe2\x80\xa6CgCompute the sum of a slice of uncompressed G1 elements.CiHelper function to add two evaluations. Panics if the \xe2\x80\xa6CjThis module contains an implementation of a verifiable \xe2\x80\xa6eTypesCiThis trait is implemented by all messages that can be \xe2\x80\xa6BjHash a binary message to a quadratic form.AjA node in the Merkle tree.AmPublic parameters of a party.CnA polynomial that is using a scalar for the variable x and \xe2\x80\xa6CjUse the secure global verifying key derived from ceremony.CiSign a message using a secret key using the signature \xe2\x80\xa6BfUse the insecure global verifying key.CgImplementation of an asynchronous verifiable secret \xe2\x80\xa6CfReturn the number of bits needed to represent this \xe2\x80\xa6C`Evaluates the polynomial at the specified value.AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ClCreate an RSA modulus from a BigUint. The modulus is not \xe2\x80\xa6111111EgTakes an input <code>ark_groth16::VerifyingKey</code> <code>vk</code> and returns a \xe2\x80\xa6222222222222222222222222222222222222CjThis module contains a selection of cryptographic hash \xe2\x80\xa6BaImplementations of HMAC and HKDF.CfInitialize JWTDetails by parsing header_base64 and \xe2\x80\xa6BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AmGet an iterator on the nodes.CkReturns a new polynomial of the given degree where each \xe2\x80\xa6CaGet a copy of the root hash of <code>self</code>.CnHex encoded 32-byte seed for deterministic key generation. \xe2\x80\xa6AmThe hex encoded discriminant.BfCreate a new signature over a message.CfSign a message with this private key and the given \xe2\x80\xa6BaThe size of this digest in bytes.CiReturn an instance of the identity element in this group.BkReturns a polynomial with the zero element.1gSee \xe2\x80\xa6Anhttps://api.arden.cc/auth/jwksAfThe range [0,\xe2\x80\xa6,2^8).BjA claim consists of value and index_mod_4.AmA node with an empty subtree.c\xe2\x80\xa6BoKey to identify a JWK, consists of iss and kid.6AkWrapper for a set of nodes.CiTrait impl\xe2\x80\x99d by nonces and IV\xe2\x80\x99s used in symmetric \xe2\x80\xa63AfGenerics below use \xe2\x80\xa6BnA Groth16 proof in the BLS12-381 construction.CkA Groth16 proof in the BN254 construction. Thin wrapper \xe2\x80\xa6BbCreate an output/hash and a proof.BhtBLS with ThresholdBls12381MinSig types.CfSee https://slack.com/.well-known/openid-configurationAkThe shares for each secret.CbGroth16 verifier over the BN254 elliptic curve \xe2\x80\xa6CaGet the byte representation of <code>self</code>.BjTry to decrypt the shares for the accuser.ClAn implementation of an Elliptic Curve VRF (ECVRF) using \xe2\x80\xa6BnCollection of errors to be used in fastcrypto.BlThe index of the share (i.e., the share id).AmThe hex encoded input string.CiHex encoding of the input string used to generate the \xe2\x80\xa6BaThe hex encoded input to the VDF.AeThe input to the VDF.CmMerge results from multiple ProcessedMessages so only one \xe2\x80\xa6CbEncoding of the proof to verify. Must be 80 bytes.BoThe proof of the correctness of the VDF output.DkProve that the <code>value</code> is in the given range using the given \xe2\x80\xa6BeGenerate a proof for the given input.Abdrand round number0CkAdd all the elements of another hash function into this \xe2\x80\xa6nZk login utilsCjReturn the canonical representation of this group element.oAes in CBC modeoAes in CTR modeCdA key of <code>N</code> bytes used with AES ciphers.oBase64 encodingoBech32 encodingAgThe range [0,\xe2\x80\xa6,2^16).AgThe range [0,\xe2\x80\xa6,2^32).AgThe range [0,\xe2\x80\xa6,2^64).BdTrait impl\xe2\x80\x99d by symmetric ciphers.AkNIZKPoK for the DL [G, xG].BdHash-to-curve domain separation tag.0CnThis represents a Dealer in the AVSS. There is exactly one \xe2\x80\xa60CdA node with children, hash value of length 32 bytes.CeRepresents a digest of <code>DIGEST_LEN</code> bytes.gSee \xe2\x80\xa6CaGenerate a key pair for proving and verification.ChGenerate a keypair using the signature scheme with a \xe2\x80\xa6CmOutput is the final output of the DKG protocol in case it \xe2\x80\xa6Dk<code>Public</code> represents the group over which the public keys are \xe2\x80\xa6CgTrait impl\xe2\x80\x99d by scalars to be used with GroupElement.BgThis represents a scalar modulo r = \xe2\x80\xa6CkA field element in the prime field of the same order as \xe2\x80\xa60BmThe SHA-2 hash function with 256 bit digests.BoThe SHA-512 hash function with 512 bit digests.CkTrait impl\xe2\x80\x99d by a key/keypair that can create signatures.:BbVerify an output/hash and a proof.CkVerify the signature against the message and public key \xe2\x80\xa6AbVerify an output .CiObtains a raw pointer suitable for use with FFI functionsBkReturns the coefficients of the polynomial.ClCommits the scalar polynomial to the group and returns a \xe2\x80\xa6ClCreate a new NIZKPoK for the DDH tuple [G, H=eG, xG, xH] \xe2\x80\xa6CkCreate a new NIZKPoK for the DL [G, xG] using the given \xe2\x80\xa6B`Decode this encoding into bytes.ClDecodes the Bech32 string to bytes, validating the given \xe2\x80\xa6ClDecodes a hex string to bytes. Both upper and lower case \xe2\x80\xa6ChDecode a Base64 string into the provided destination \xe2\x80\xa6ClTry to correct the input and return the decoded message. \xe2\x80\xa6BeReturns the degree of the polynomial.CgGenerate a digest of the current state of this hash \xe2\x80\xa6CmCompute the digest of the given data and consume the hash \xe2\x80\xa6AoCompute 2 * Self = Self + Self.AkEncode bytes into a string.CnEncodes bytes into a Bech32 encoded string, with the given \xe2\x80\xa6C`Hex encoding is without \xe2\x80\x9c0x\xe2\x80\x9d prefix. See \xe2\x80\xa6BfEncode the input byte slice as Base64.CmEncode the message using the Reed-Solomon code defined by \xe2\x80\xa6CgDerive a new random oracle from the current one and \xe2\x80\xa6BgInsert an item into this hash function.CmCompute the Jacobi symbol (a/m) for odd m. If m is prime, \xe2\x80\xa6BdA simple Merkle tree implementation.CeModule minimizing the size of public keys. Module \xe2\x80\xa6CgHex-encoded Sha512 hash of the proof. Must be 64 bytes.C`Compute both hash and proof for the given input.AfThe output of the VDF.CiReturns the padded version of the field element. This \xe2\x80\xa6AcGet the public key.CgComputes a uniformly random element using rejection \xe2\x80\xa6BjRemove an element from this hash function.AmName of the signature scheme.00nPossibly emptyBbCopy the digest into a new vector.BfDecodes this Base64 encoding to bytes.BcDecodes this hex encoding to bytes.CmReturn all evaluations in this range as a vector, ordered \xe2\x80\xa6CjProcess the given data, and update the internal of the \xe2\x80\xa6CnUse Self to verify that the provided signature for a given \xe2\x80\xa6CeVerify this aggregate signature assuming that all \xe2\x80\xa6CmVerifies a range proof: That the commitment is to a value \xe2\x80\xa6CeVerify a signature on a message with this public key.AdVerify this NIZKPoK.CnVerify a signed message. The verification uses SHA-256 for \xe2\x80\xa6EbVerifies an ECDSA signature for <code>msg</code> using <code>pk</code> and the \xe2\x80\xa6BeVerify the correctness of this proof.CkVerify a signature on a given message. This is standard \xe2\x80\xa6BgVerify the output and proof from a VDF.CnVerify Groth16 proof using the prepared verifying key (see \xe2\x80\xa60CjThe commitment of the secret polynomial created by the \xe2\x80\xa6CfGet the weight of this node (number of shares it has).0AnAn address on the Sui network.C`Type for input keying material in hkdf_sha3_256.AnType for key in hmac_sha3_256.CdTrait impl\xe2\x80\x99d by a public / private key pair in \xe2\x80\xa6CgThe message broadcast by the dealer, containing the \xe2\x80\xa6BdThe message broadcast by the dealer.ClMessage holds all encrypted shares a dealer sends during \xe2\x80\xa6CgCompute the composition of this quadratic form with \xe2\x80\xa6DeDecrypt <code>ciphertext</code> using the given IV and return the \xe2\x80\xa6CjAssumption: Verify is called before decrypt and do not \xe2\x80\xa6CfDivide self by divisor, returning the quotient and \xe2\x80\xa6CiThis module contains an implementation of the Ed25519 \xe2\x80\xa6CdGet a string representation of this Base64 encoding.DhEncrypt <code>plaintext</code> using the given IV and return the result.AjGet the parsed iss string.AjGet the parsed kid string.CdConsume the polynomial and return the constant term.CmReturns true iff this is the identity point aka the point \xe2\x80\xa6BkThe hex encoded input to the hash function.CdModule minimizing the size of signatures. Module \xe2\x80\xa6AdGet the private key.BkRecover the public key from this signature.ChUpon receiving t valid responses to a complaint, the \xe2\x80\xa60CeA Schnorr signature scheme as defined in BIP-0340 \xe2\x80\xa6BnCompute the output of the VRF with this proof.CgA G1 point in BN254 serialized as a vector of three \xe2\x80\xa6CgA G2 point in BN254 serialized as a vector of three \xe2\x80\xa6CeTrait for group elements that has a fast doubling \xe2\x80\xa6AfBase64 encoding trait.CgTrait representing a general binary-to-string encoding.AmCompute VDF output and proof.gSee \xe2\x80\xa6ChTrait impl\xe2\x80\x99d by cryptographic material that can be \xe2\x80\xa6Cahttps://oauth2.playtron.one/.well-known/jwks.jsonCnThis represents a Receiver in the AVSS who receives shares \xe2\x80\xa6BmThe SHA-3 hash function with 256 bit digests.BmThe SHA-3 hash function with 512 bit digests.Cehttps://auth.3dos.io/.well-known/openid-configurationChA proof that the output of a VRF was computed correctly.CkBorrow a byte slice representing the serialized form of \xe2\x80\xa6CeThis module contains an implementation of the BLS \xe2\x80\xa6CfGroth16 verifier over the BLS12-381 elliptic curve \xe2\x80\xa6BhExecute the previous two steps together.C`Encodings of binary data such as Base64 and Hex.BlEvaluate the random oracle on a given input.CjEvaluate this VDF and return the output and a proof of \xe2\x80\xa6BjRetrieve result and consume hash function.DgParse an <code>RSAPublicKey</code> from an ASN.1 DER (Distinguished \xe2\x80\xa6C`Converts a DER-encoded byte slice to a signatureCbReturns the OIDCProvider for the given iss string.CnParse an RSA modulus from a decimal string. The modulus is \xe2\x80\xa6BkGenerate a new keypair using the given RNG.CcGenerate a new random instance using the given RNG.1CnGet the evaluation point for the given index. Panics if it \xe2\x80\xa6CkCall the salt server for the given jwt_token and return \xe2\x80\xa6AfCompute self * scalar.BaPoseidon hash function over BN254CnPoseidon hash function over BN254. The input vector cannot \xe2\x80\xa6CmA valid discriminant should be a negative prime congruent \xe2\x80\xa6CkReturns the unpadded version of the field element. This \xe2\x80\xa6AfGroth16 SNARK verifierAnZk login structs and utilitiesAcAES128 in CTR-mode.ClAES128 in GCM-mode (authenticated) using the given nonce \xe2\x80\xa6AcAES192 in CTR-mode.AcAES256 in CTR-mode.ClAES256 in GCM-mode (authenticated) using the given nonce \xe2\x80\xa6lExample: \xe2\x80\xa6CjA complaint by an accuser that it could not decrypt or \xe2\x80\xa6lAssumptions:Cchttps://accounts.credenza3.com/openid-configurationBjThis holds the output of Poly::eval_range.CgA circuit that checks a parametrized number of R1CS \xe2\x80\xa6BhElements of the group G_1 in BLS 12-381.BhElements of the group G_2 in BLS 12-381.CkElements of the subgroup G_T of F_q^{12} in BLS 12-381. \xe2\x80\xa6BaThe type of the input to the VDF.CeReader struct to parse all fields in a JWK from JSON.CmStruct that represents a standard JWT header according to \xe2\x80\xa6BnThe KECCAK hash function with 256 bit digests.ChThis is a test issuer maintained by Mysten that will \xe2\x80\xa6CbThe type of the proof of correctness for this VDF.CjDecoder for Reed-Solomon codes. This can correct up to \xe2\x80\xa6Di<code>Signature</code> represents the group over which the signatures \xe2\x80\xa6CfCombine signatures into a single aggregated signature.CfInterpolate partial signatures to recover the full \xe2\x80\xa6CnParse the proving service response and pass in the address \xe2\x80\xa6BcParse the proof from a json string.ClCompute a valid discriminant (aka a negative prime equal \xe2\x80\xa6CoGenerate a random element of the subgroup ZN* / &lt;\xc2\xb11&gt; \xe2\x80\xa6CcReturn an instance of the generator for this group.CmReturn a generator (or, more precisely, an element with a \xe2\x80\xa6CjCalculate the nonce for the given parameters. Nonce is \xe2\x80\xa6EgGet the <code>MerkleProof</code> for the leaf at <code>leaf_index</code> consisting \xe2\x80\xa6AgGet the zk login proof.CnCall the prover backend to get the zkLogin inputs based on \xe2\x80\xa6CkReturns the log base 2 of b. There is an exception: for \xe2\x80\xa6A`Number of nodes.BdPlaintext to encrypt (hex, 32 bytes)CgThis module contains an implementation of the ECDSA \xe2\x80\xa6CbImplementation of the Secp256k1 (aka K-256) curve.1CnImplementation of the Secp256r1 (aka P-256) curve. This is \xe2\x80\xa6CiSerialize the prepared verifying key to its vectors form.BeHex encoded signature to be verified.Aodrand signature (hex, 48 bytes)CaTrait impl\xe2\x80\x99d by RNG\xe2\x80\x99s accepted by fastcrypto.CbThe BLAKE2-256 hash function with 256 bit digests.CbThe length of the digests used in the merkle tree.CmImplementation of Wesolowski\xe2\x80\x99s VDF construction over an \xe2\x80\xa6BoAn encryption of 32 bytes message following \xe2\x80\xa6ClA struct of parsed JWT details, consists of kid, header, \xe2\x80\xa6c\xe2\x80\xa6EgMerkle tree using a hash function <code>T</code> (default: <code>Blake2b256</code>) \xe2\x80\xa6BdThe type of the output from the VDF.CeSimple ECIES encryption using a generic group and \xe2\x80\xa6AhBulletproof Range ProofsCjType of scalars used in the [Self::mul] multiplication \xe2\x80\xa6CjA batch of shares for a single share index, containing \xe2\x80\xa6CiIndexes of shares/private keys (0 is reserved for the \xe2\x80\xa6CiTrait impl\xe2\x80\x99d by private (secret) keys in asymmetric \xe2\x80\xa6C`This is a test issuer that will return a JWT \xe2\x80\xa6CnA test vector containing a signature over MSG encoded as a \xe2\x80\xa6CaA keypair for a verifiable random function (VRF).CjEnum to specify the environment to use for verifying keys.CkObtains a raw mutable pointer suitable for use with FFI \xe2\x80\xa6CgImplementation of an asynchronous verifiable secret \xe2\x80\xa6CaBit length of the discriminant (default is 3072).AkCiphertext to decrypt (hex)ClList of complaints against other parties. Empty if there \xe2\x80\xa6ClThis module contains conversion function between scalars \xe2\x80\xa6BjDecode a Base64 string into a byte vector.CmEvaluate the polynomial for all x in the range [1,\xe2\x80\xa6,m]. \xe2\x80\xa6CkFetch JWKs from the given provider and return a list of \xe2\x80\xa6BlParse an object from its byte representationAjEncodes bytes as a Base64.AnEncodes bytes as a hex string.CkParse signature from binary representation according to \xe2\x80\xa6CiReturns the provider config consisting of iss and jwk \xe2\x80\xa6ClReturns true iff the y-coordinate of this point is even. \xe2\x80\xa6CmThis module contains an implementation of a hash-to-prime \xe2\x80\xa6BnInsert multiple items into this hash function.AiThe number of iterations.jIterationsClThis module contains implementations of optimised scalar \xe2\x80\xa6ClParse the JWK bytes received from the given provider and \xe2\x80\xa6CjThe public key corresponding to the secret key used to \xe2\x80\xa6BcPublic key to verify the signature.CkGiven a set of shares with unique indices, compute what \xe2\x80\xa6DhGiven exactly <code>t</code> polynomial evaluations, it will recover \xe2\x80\xa6BnRemove multiple items from this hash function.CmA hex encoding of the secret key. Corresponds to a scalar \xe2\x80\xa6BkHex encoded secret key string used to sign.CeCreate a PoK of a private key such that the given \xe2\x80\xa6B`AES in GCM mode (authenticated).BgDecode a base64 string into hex string.ChDefault hash function used for signing and verifying \xe2\x80\xa60Cbhttps://auth.evefrontier.com/.well-known/jwks.jsonCnSerialization of GT elements is typically not standardized \xe2\x80\xa6BgDecode a hex string into base64 string.DcA proof that some data is at index <code>leaf_index</code> in a \xe2\x80\xa6CcThe length of this hash functions digests in bytes.BcPrivate key/seed of any/fixed size.BjSize of scalars in the BN254 construction.DiDerive the <code>SilentDebug</code> trait, which is an implementation \xe2\x80\xa6CkTrait impl\xe2\x80\x99d by concrete types that represent digital \xe2\x80\xa6BkThe type of the digest when this is hashed.C`Convert the Circom G1/G2/GT to arkworks G1/G2/GTCjThis module contains implementation of imaginary class \xe2\x80\xa6CkThe commitments to the polynomials will be used for key \xe2\x80\xa6ClDeserialize a serialized Groth16 proof using arkworks\xe2\x80\x99 \xe2\x80\xa6CeDeserialize a serialized Groth16 verifying key in \xe2\x80\xa6CnDeserialize the prepared verifying key from the serialized \xe2\x80\xa6CkGet the length of Base64 produced by encoding the given \xe2\x80\xa6BaParse JWK from the reader struct.BaInitialize ZkLoginInputs from theCjGiven a set of shares with unique indices, compute the \xe2\x80\xa6CnReturns true if this is an element of the group defined by \xe2\x80\xa6CnCreate a new set of nodes. Nodes must have consecutive ids \xe2\x80\xa6CkNormalizes a signature to a \xe2\x80\x9clow S\xe2\x80\x9d form. In ECDSA, \xe2\x80\xa6DjCreate a proof that all the given <code>values</code> are in the range \xe2\x80\xa6CgThis module contains an implementation of the ECDSA \xe2\x80\xa60ChSerialize scalar into a byte vector in little-endian \xe2\x80\xa6DgVerify that the root of <code>self</code> matches the provided root \xe2\x80\xa6CjAES256 in GCM-SIV (authenticated) mode with 96 bit nonces.CiA Confirmation is sent during the second phase of the \xe2\x80\xa6BlNIZKPoK for the DDH tuple [G, H=eG, xG, xH].CdA discriminant for an imaginary class group. The \xe2\x80\xa6BiSample a random discriminant from a seed.CnA dummy circuit that checks an addition constraint between \xe2\x80\xa6CkA field element in the BN254 construction. Thin wrapper \xe2\x80\xa6AlGeneral cryptographic error.CgTrait impl\xe2\x80\x99d by elements of an additive cyclic group.CmTrait implemented by hash functions providing a output of \xe2\x80\xa6CiWrapper of a value that is associated with a specific \xe2\x80\xa6AaInput is to long.BgInvalid value was given to the functionBgInvalid proof was given to the functionCiA Multiset Hash is a homomorphic hash function, which \xe2\x80\xa6AiSupported OIDC providers.ClThe presigs iterator has no more values. Please create a \xe2\x80\xa6CfThis implements Pietrzak\xe2\x80\x99s VDF construction from \xe2\x80\xa6AlRandom Oracle from SHA3-512.AbAn ECDSA signatureCoTrait ThresholdBls provides sign &amp; verify functions for \xe2\x80\xa6CmRepresents a public key of which is use to verify outputs \xe2\x80\xa6CiTrait impl\xe2\x80\x99d by public keys in asymmetric cryptography.CfA Groth16 verifying key in the BLS12-381 construction.CkA Groth16 verifying key in the BN254 construction. Thin \xe2\x80\xa6AnThe struct for zk login proof.CnVerify a batch of aggregate signatures, each consisting of \xe2\x80\xa6ClImplementation of Pedersen Commitments and Bulletproofs, \xe2\x80\xa6CjCombine multiple outputs from different dealers into a \xe2\x80\xa6CnRecomputes the Merkle root from the proof and the provided \xe2\x80\xa6ClReturns an upper bound for the degree of the polynomial. \xe2\x80\xa6CnDiscriminants of quadratic forms are negative primes which \xe2\x80\xa6CnCompute the discriminant of this quadratic form, eg. b^2 - \xe2\x80\xa6CfConverts a 64-byte compact-encoded byte slice to a \xe2\x80\xa6CdConverts a \xe2\x80\x9clax DER\xe2\x80\x9d-encoded byte slice to a \xe2\x80\xa6CkReturn the OIDC URL for the given parameters. Crucially \xe2\x80\xa6BjThe JWK url string for the given provider.BeAlternative to new(), to be used for:CcSign a message using the private share/partial key.CnImplementations of the ristretto255 group which is a group \xe2\x80\xa6CkGet the share ids of a node (ordered). Returns error if \xe2\x80\xa6AjTotal weight of the nodes.CkVerifies that a range proof that all commitments are to \xe2\x80\xa6CmCheck that a pair (k, H) satisfies H = k*G using a random \xe2\x80\xa6CiVerifies the proof given a Merkle root and the leaf data.BaChecks if a given share is valid.AdZk login entrypointsChTrait impl\xe2\x80\x99d by signatures in asymmetric cryptography.CnThe length of public keys when using the min_pk module and \xe2\x80\xa6CkThe length of public keys when using the min_sig module \xe2\x80\xa6CkTrait impl\xe2\x80\x99d by encryption keys in symmetric cryptographyAbInput is to short.CiThe type of the parameter which uniquely defines this \xe2\x80\xa6CmThe output of a receiver after a single instance of AVSS: \xe2\x80\xa6ChAn iterator that yields presigning tuples (i, t_i, p_i).CmA binary quadratic form, (a, b, c) for arbitrary integers \xe2\x80\xa6CnAll the shares given to a node. One share per the node\xe2\x80\x99s \xe2\x80\xa6ClThis represents a set of shares for a node. A total of L \xe2\x80\xa6DkDerive the <code>SilentDisplay</code> trait, which is an implementation \xe2\x80\xa6CmError in error decoding because there are too many errors \xe2\x80\xa6CjRepresents a private key used to compute outputs for a \xe2\x80\xa6CkAll inputs required for the zk login proof verification \xe2\x80\xa6DeEncode input byte slice into a <code>String</code> containing Base64.CiHMAC-based Extract-and-Expand Key Derivation Function \xe2\x80\xa6CgKeyed-Hash Message Authentication Code (HMAC) using \xe2\x80\xa6CmMulti-pairing operation that computes the sum of pairings \xe2\x80\xa6B`Get an iterator on the node ids.BfThe number of variables to the circuitCjReturns a new polynomial of the given degree where the \xe2\x80\xa6BfSerializes the signature in DER formatCdVerify the correctness of this proof and VRF output.CjReturns the x-coordinate of this point as a big-endian \xe2\x80\xa6BiAES128 in CBC-mode using PKCS #7 padding.BiAES256 in CBC-mode using PKCS #7 padding.CjA struct that stores a Bn254 Fq field element as 32 bytes.CjA struct that stores a Bn254 Fr field element as 32 bytes.AaEd25519 key pair.BjExtend implementations of Add, Sub, Mul\xe2\x80\xa6AiMessage should be ignoredBiInvalid message was given to the functionCjTrait for groups that support multi-scalar multiplication.CfThe provider config consists of iss string and jwk \xe2\x80\xa6DkThe output after combining multiple <code>PartialOutputs</code>, either \xe2\x80\xa6CkThe output of a receiver which is a batch of shares and \xe2\x80\xa6CiThis trait allows using a HashFunctionWrapper where a \xe2\x80\xa6CiRepresents a point in the Ristretto group for Curve25519.ChAn implementation of Wesolowski\xe2\x80\x99s VDF construction \xe2\x80\xa6BfThe share for the blinding polynomial.BkCreate the first message to be broadcasted.CnThe Dealer samples nonces, generates shares and broadcasts \xe2\x80\xa6CnThe Dealer generates shares for the secrets and broadcasts \xe2\x80\xa6BlSimple circuits used in benchmarks and demosCgThis module contains test vectors for all signature \xe2\x80\xa6CiFastcrypto-zkp is an experimental crate that offers a \xe2\x80\xa6C`Verify a signature done by a partial key holder.CkCalculate the Poseidon hash of an array of inputs. Each \xe2\x80\xa6BiPrepare the public inputs for use in [\xe2\x80\xa6BaGet an iterator on the share ids.CkCreate a new signature using the given hash function to \xe2\x80\xa60kCompute \xe2\x80\xa6CfVerify proof with a given verifying key in [struct \xe2\x80\xa6DjVerify a signed message. The message, <code>hashed</code>, must be the \xe2\x80\xa6BkCircom-compatible deserialization of pointsAdBLS 12-381 key pair.0BnCollection of errors to be used in fastcrypto.BfA response struct for the salt server.ClTrait for objects that support an insecure default value \xe2\x80\xa6ClNot enough inputs were given to the function, retry with \xe2\x80\xa6BmThe inputs given does not have enough weight.CiA point on the Secp256k1 curve in projective coordinates.CiA point on the Secp256r1 curve in projective coordinates.CnThis represents an element of the subgroup of an RSA group \xe2\x80\xa6DgA recovery package that allows decrypting a <em>specific</em> ECIES \xe2\x80\xa6AdRepresents a scalar.Cghttps://test.auth.evefrontier.com/.well-known/jwks.jsonBkVerify a drand signature for a given round.B`Decode a Base64 string in-place.E`The element <code>- delta * H</code> in <code>E::G2</code>, for use in pairings.CnCompute a single digest from all slices in the iterator in \xe2\x80\xa6CdA crate that implements threshold BLS (tBLS) and \xe2\x80\xa6E`The element <code>- gamma * H</code> in <code>E::G2</code>, for use in pairings.CbGet the byte array representation of this element.Bhthe number of constraints to the circuitCiProcess a message and create the second message to be \xe2\x80\xa6CnEach receiver processes the message, verifies and decrypts \xe2\x80\xa60Cfdrand signature for the required round (hex, 48 bytes)CmTotal weight of a subset of the parties. Returns error if \xe2\x80\xa6ClCheck that a triplet (k, G, H) satisfies H = k*G using a \xe2\x80\xa6B`Entry point for the ZkLogin API.BhThe element vk.gamma_abc_g1, aka the \xe2\x80\xa6C`Decrypt a ciphertext. Returns a plaintext (hex).AcEd25519 public key.AbEd25519 signature.C`Encrypt a plaintext. Returns a ciphertext (hex).CjTrait impl\xe2\x80\x99d by a keys/secret seeds for generating a \xe2\x80\xa6BdStruct wrapping an instance of a \xe2\x80\xa6AfInput length is wrong.BkInvalid signature was given to the functionCiThe result of a Receiver processing a Message: Either \xe2\x80\xa6ClThe result of processing a message by a receiver: either \xe2\x80\xa6ClWrapper for collecting everything related to a processed \xe2\x80\xa6CnTrait for scalar multiplication for a fixed group element, \xe2\x80\xa6CiA Schnorr public key as defined in BIP-340. The point \xe2\x80\xa6CjA Schnorr signature as defined in BIP-340. The r point \xe2\x80\xa6BbSecp256k1 public/private key pair.BbSecp256r1 public/private key pair.CiThis service holds the node\xe2\x80\x99s private key. It takes \xe2\x80\xa6DfThe element <code>e(alpha * G, beta * H)</code> in <code>E::GT</code>.ClDecodes a hex string to bytes. Both upper and lower case \xe2\x80\xa6CfThe encrypted shares created by the sender. Sorted \xe2\x80\xa6DfLike <code>cmp::Eq</code> but faster and with no guarantees across \xe2\x80\xa6CgCalculate the Sui address based on address seed and \xe2\x80\xa6AlGet the address seed string.CjUpon receiving a complaint, a receiver verifies it and \xe2\x80\xa60ClThis method computes the linear combination of the given \xe2\x80\xa6ChScale each of the polynomials with the corresponding \xe2\x80\xa6CmPrecompute discrete log table for use in decryption. This \xe2\x80\xa6ClReturns the i\xe2\x80\x99th coefficient for this polynomial. If i \xe2\x80\xa6CnSerialize a vector of elements of type T into a byte array \xe2\x80\xa6BiGet the node corresponding to a share id.B`Sign as a recoverable signature.ChGiven a 33-byte public key bytes (flag || pk_bytes), \xe2\x80\xa6CnVerify the signature using the given hash function to hash \xe2\x80\xa60BlAES128 in CBC-mode using ANSI X9.23 padding.BkAES128 in CBC-mode using ISO 10126 padding.BlAES256 in CBC-mode using ANSI X9.23 padding.BkAES256 in CBC-mode using ISO 10126 padding.AfBLS 12-381 public key.0AeBLS 12-381 signature.0CbURL-safe Base64 encoding <em>without</em> padding.CkA response to a complaint, containing the responder\xe2\x80\x99s \xe2\x80\xa6ChFixed 3072 bit discriminant. Generated from the seed \xe2\x80\xa6AdEd25519 private key.ChTrait impl\xe2\x80\x99d by public / private keypairs that can \xe2\x80\xa6CaA Schnorr private key. The scalar cannot be zero.DgTypes that can be converted to a vector of <code>F</code> elements. \xe2\x80\xa60DgLike <code>cmp::Cmp</code> but faster and with no guarantees across \xe2\x80\xa6EcThis crate contains the <code>SilentDebug</code> and <code>SilentDisplay</code> \xe2\x80\xa6CiIf all elements in this iterator have the same value, \xe2\x80\xa6BgCheck if the input is a probable prime.ChCreate a prepared verifying key for Groth16 over the \xe2\x80\xa6CgDeserialize bytes as an Arkwork representation of a \xe2\x80\xa6ChDeserialize bytes as an Arkworks representation of a \xe2\x80\xa6CmRecover the public key from this signature. Assuming that \xe2\x80\xa6CjRecover public key from signature using the given hash \xe2\x80\xa6CcCompute input * 2^repetitions by repeated doubling.BjSerializes the signature in compact formatCmGet all shares this node has for the i-th secret/nonce in \xe2\x80\xa6ClThis module implements threshold Schnorr signatures. The \xe2\x80\xa6BhSerialize the element into a byte array.CkCheck that partial public keys form a polynomial of the \xe2\x80\xa6CmChecks that a given set of evaluations is consistent with \xe2\x80\xa6AgBLS 12-381 private key.0CkThe key pair bytes length used by helper is the same as \xe2\x80\xa6CiSerializer in little endian format. This trait can be \xe2\x80\xa60CgCryptographic material with an immediate conversion \xe2\x80\xa6BcGeneral opaque cryptographic error.CmTrait for groups that have a standardized \xe2\x80\x9chash_to_point\xe2\x80\xa6CgThe degree of the Merkle tree used to hash multiple \xe2\x80\xa6CdThe number of precomputed points used for scalar \xe2\x80\xa6AeSecp256k1 public key.AjSecp256k1 ECDSA signature.AeSecp256r1 public key.AdSecp256r1 signature.D`Given a byte array of length <code>N * SIZE_IN_BYTES</code>, \xe2\x80\xa6CdEncode bytes as a hex string with a \xe2\x80\x9c0x\xe2\x80\x9d prefix.CkThe commitments to the polynomials will be used for key \xe2\x80\xa6CjConstruct a RistrettoPoint from the given data using a \xe2\x80\xa6CkWhen the protocol is used in the sync setting with high \xe2\x80\xa6CjSign a message using one of more private share/partial \xe2\x80\xa6CkVerify a recoverable signature by recovering the public \xe2\x80\xa6CkVerify that the given parameters (name, value, aud, iss \xe2\x80\xa6CiTrait impl\xe2\x80\x99d by symmetric ciphers for authenticated \xe2\x80\xa6oExternal types.ChTrait for groups that have a reduction from a random \xe2\x80\xa6BnThis wraps a digest::Digest as a HashFunction.CmSize of a serialized point in bytes. This uses compressed \xe2\x80\xa6AfSecp256k1 private key.AfSecp256r1 private key.B`Serialization of internal types.CcThe reader struct for the proving service response.CgAlternative to complete() - Optimistic version that \xe2\x80\xa6CnGet a string representation of this Hex encoding with a \xe2\x80\x9c\xe2\x80\xa6BjDeserialize the element from a byte array.DkParse an <code>RSAPublicKey</code> from its components, eg. the modulus \xe2\x80\xa6ClThe general serialize method that takes in customization \xe2\x80\xa60CkVerify that the given parameters (address_seed and iss) \xe2\x80\xa6CkDeserializer in little endian format. This trait can be \xe2\x80\xa60CgFaster deserialization in case the input is trusted \xe2\x80\xa6DcAn <code>N</code> byte initialization vector used with AES ciphers.CeA prepared Groth16 verifying key in the BLS12-381 \xe2\x80\xa6CnThis is a helper function to store a pre-processed version \xe2\x80\xa60BhTrait impl\xe2\x80\x99d by recoverable signaturesBeSize of a serialized scalar in bytes.CbThe size of the sliding window used for scalar \xe2\x80\xa6CjGiven enough partial signatures, aggregate them into a \xe2\x80\xa6CmDerive a new verifying key from an existing one and a Sui \xe2\x80\xa6CjCreate a scalar from a big-endian byte representation, \xe2\x80\xa6CeConstruct a RistrettoScalar by reducing a 32-byte \xe2\x80\xa6CgCalculate the Sui address based on address seed and \xe2\x80\xa6ClCompute the extended GCD of two polynomials. Returns (g, \xe2\x80\xa6ClVerify a set of signatures done by a partial key holder. \xe2\x80\xa6ClCalculate the poseidon hash of the field element inputs. \xe2\x80\xa6ClVerify this aggregate signature where the signatures are \xe2\x80\xa6CnAn uncompressed serialization of a G1 element. This format \xe2\x80\xa6CbThe response struct for the test issuer JWT token.ChUnique processed messages that are being used in the \xe2\x80\xa6DhCreate the <code>MerkleTree</code> as a commitment to the provided data.CjInterpolate shares from multiple outputs to create new \xe2\x80\xa6DiDecrypt <code>ciphertext</code> using the given IV and authentication \xe2\x80\xa6CnThe general deserialize method that takes in customization \xe2\x80\xa60DhEncrypt <code>plaintext</code> using the given IV and authentication \xe2\x80\xa6CkHashes the given message and maps the result to a group \xe2\x80\xa6CiTrait impl\xe2\x80\x99d by aggregated signatures in asymmetric \xe2\x80\xa6BeThe length of a private key in bytes.ClThe key pair bytes length is the same as the private key \xe2\x80\xa6DjSimilar to <code>reduce_mod_uniform_buffer</code>, returns a result of \xe2\x80\xa6DkCreate the <code>MerkleTree</code> as a commitment to the provided data \xe2\x80\xa6CjEmulates the output of an insecure DKG protocol (to be \xe2\x80\xa6CfReturn the token exchange URL for the given auth code.ChIf all shares have the same batch size, return that. \xe2\x80\xa6DeChecks if vectors v1=(a1<em>G1, \xe2\x80\xa6, an</em>G1) and v2=(a1\xe2\x80\x99*G2, \xe2\x80\xa6CnA proof that some leaf is not in a Merkle tree. To be used \xe2\x80\xa6CmImplementation of [ThresholdBls] for BLS12-381-min-sig. A \xe2\x80\xa6DhCreate the <code>MerkleTree</code> as a commitment to the provided data.BgAssumption: Verify is called before \xe2\x80\xa6DjCreate a new <code>G1ElementUncompressed</code> from a byte array. The \xe2\x80\xa6CePads a stream of bytes and maps it to a field elementCjConvert a non-recoverable signature into a recoverable \xe2\x80\xa6CnRecover the public key used to create this signature. This \xe2\x80\xa6CaVerify Groth16 proof over the BLS12-381 curve \xe2\x80\xa6CiVerify Groth16 proof using the serialized form of the \xe2\x80\xa6CnVerify Groth16 proof using the serialized form of the four \xe2\x80\xa6BcThe length of a signature in bytes.ClMulti-recipient encryption with a proof-of-possession of \xe2\x80\xa6ClThe key pair bytes length is the same as the private key \xe2\x80\xa60ChThis scalar multiplier uses pre-computation with the \xe2\x80\xa6BdThe length of a public key in bytes.BkAggregation of multiple Ed25519 signatures.Dk<code>EllipticCurveMultisetHash</code> (ECMH) is a homomorphic multiset \xe2\x80\xa6CbScalars given to the API are expected to be in \xe2\x80\xa6ClTrait implemented by elements of an additive group where \xe2\x80\xa68CmProcessed messages that were not excluded after the third \xe2\x80\xa6CiCalculate the poseidon hash from selected fields from \xe2\x80\xa6CfCreate a new quadratic form given only the a and b \xe2\x80\xa6CeConstruct a RistrettoScalar by reducing a 64-byte \xe2\x80\xa6CiCall test issuer for a JWT token based on the request \xe2\x80\xa6BnAggregation of multiple BLS 12-381 signatures.0BeThe length of a private key in bytes.?CkCompute the message polynomial. Returns an error if the \xe2\x80\xa6ChSign as a recoverable signature using the given hash \xe2\x80\xa6CnCreate a new recoverable signature over the given message. \xe2\x80\xa6CgThe output of the Poseidon hash function is a field \xe2\x80\xa6??ChCompute the non-inclusion proof for the target leaf. \xe2\x80\xa6CmGenerate partial threshold Schnorr signatures for a given \xe2\x80\xa6CeAlternative to process_message for additional checks:CnVerify Groth16 proof using the prepared verifying key (see \xe2\x80\xa6CmLift an x-coordinate to a point on the curve with an even \xe2\x80\xa699CkVerify a recoverable signature by recovering the public \xe2\x80\xa6AdSecp256k1 signature.AdSecp256r1 signature.ClMacro for generating a new alias for BytesRepresentation \xe2\x80\xa6CnDefault size in bytes of the Fiat-Shamir challenge used in \xe2\x80\xa60ClThis discriminant size is based on a lower bound from \xe2\x80\x9c\xe2\x80\xa6CgAlternative to complete() - Optimistic variant that \xe2\x80\xa6ClVerify a proof against its public inputs using the fixed \xe2\x80\xa6ClLength of a compact signature followed by one extra byte \xe2\x80\xa6CiGenerate a random quadratic form from a seed with the \xe2\x80\xa6CnMacro for generating Serialize/Deserialize for a type that \xe2\x80\xa6")